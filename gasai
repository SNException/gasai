#!/usr/bin/java --source 17

//                        _ 
//                       (_)
//   __ _  __ _ ___  __ _ _ 
//  / _` |/ _` / __|/ _` | |
// | (_| | (_| \__ \ (_| | |
//  \__, |\__,_|___/\__,_|_|
//   __/ |                  
//  |___/                   
//             - Niklas Schultz
//
//
// gasai - personal "security" tool for my paranoia :)
//

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.security.MessageDigest;
import java.security.Security;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.LinkedHashMap;
import java.util.Set;
import java.util.concurrent.atomic.LongAdder;

// todo(nschultz): Sort files alphabetically before processing
// java.util.Collections.sort(list)
//
// todo(nschultz): Make this script usable on windows
//
// todo(nschultz): Right now the last modified time of the .gasai_hashes file is used to tell the user
// agains which snapshot he is running the check. However that is error prone since the file could be changed
// (e.g by touch command). It would be better (?) if the timestamp is written as one of the first lines of the
// .gasai_hashes file.
//
// todo(nschultz): Since we set our own limit of tput cols to 80 we have to do some adjustments for ADDED, SKIPPED, MISSING
// since we used OK as our "template".
//
// todo(nschultz): What happens when we set a maxsize limit to, say 3 megabytes, and the file gets changed afterwards to a size
// bigger than this limit? Well, it will get marked with skipped but is that really what we want in this case?
//
// todo(nschultz): Option to skip non present directories (e.g if they are not yet mounted, or connected)
//
// todo(nschultz): What happens if recursive is configured and you specificy another subdirectory
public final class gasai {

    private static final String VERSION = "0.1.0";

    private static final String VT_RESET     = "\u001B[0m";
    private static final String VT_BOLD      = "\u001B[1m";
    private static final String VT_RED_FG    = "\u001B[31m";
    private static final String VT_GREEN_FG  = "\u001B[32m";
    private static final String VT_YELLOW_FG = "\u001B[33m";
    private static final String VT_PURPLE_FG = "\u001B[35m";

    private static final int ERR_SUCCESS =  0;
    private static final int ERR_ARGS    = -1;
    private static final int ERR_TERM    = -2;
    private static final int ERR_SNAP    = -4;
    private static final int ERR_LIST    = -8;
    private static final int ERR_HASH    = -16;
    private static final int ERR_RC      = -32;
    private static final int ERR_OS      = -64;
    private static final int ERR_INIT    = -128;
    
    private static final Path rcFile = Path.of(System.getProperty("user.home"), ".gasairc");

    private static final class Config {
        private Config() { assert false; }

        public static String[] dirs     = null;
        public static int delayMillis   = 0;
        public static int maxSizeKB     = 0;
        public static boolean verbose   = false;
        public static String hash       = null;
        public static int readSize      = 0;
        public static Path snapshotFile = null;
        public static Path logFile      = null;
        public static boolean recursive = false;
    }

    private static final class CheckResults {
        public final int processed;
        public final int changed;
        public final int added;
        public final int missing;
        public final int skips;

        public CheckResults(final int processed, final int changed, final int added, final int missing, final int skips) {
            this.processed = processed;
            this.changed   = changed;
            this.added     = added;
            this.missing   = missing;
            this.skips     = skips;
        }
    }

    private static final class UpdateResults {
        public final int processed;
        public final int skips;

        public UpdateResults(final int processed, final int skips) {
            this.processed = processed;
            this.skips     = skips;
        }
    }

    private static String execShellCommandWait(final String cmdLine) {
        try {
            final Process process = Runtime.getRuntime().exec(cmdLine);
            process.waitFor();

            final int exitValue = process.exitValue();
            if (exitValue == 0) {
                final InputStream in = process.getInputStream();
                final StringBuilder result = new StringBuilder();
                for (;;) {
                    final byte[] buf = new byte[4096];
                    final int readBytes = in.read(buf);
                    if (readBytes < 0) {
                        return result.toString();
                    }
                    result.append(new String(buf, 0, readBytes, StandardCharsets.UTF_8));
                }
            } else {
                final InputStream in = process.getErrorStream();
                final StringBuilder result = new StringBuilder();
                for (;;) {
                    final byte[] buf = new byte[4096];
                    final int readBytes = in.read(buf);
                    if (readBytes < 0) {
                        return result.toString();
                    }
                    result.append(new String(buf, 0, readBytes, StandardCharsets.UTF_8));
                }
            }
        } catch (final IOException ex) {
            return null;
        } catch (final InterruptedException ex) {
            assert false : String.format("Not supposed to interrupt thread '%s'");
            return null;
        }
    }

    private static boolean listFiles(final String start, final String filter,
                                     final ArrayList<String> files, final ArrayList<String> skips,
                                     final boolean recursive) {
        assert start  != null;
        assert filter != null;
        assert files  != null;

        final File directory = new File(start);
        final File[] list = directory.listFiles();
        if (list != null) {
            for (final File file : list) {
                if (file.getName().equals("X11")) {
                    continue; // note(nschultz): hack for Linux
                }
                if ((file.length() / 1024) > Config.maxSizeKB) {
                    skips.add(file.getAbsolutePath());
                    continue; // note(nschultz): prevent possible OOM
                }

                if (file.isFile()) {
                    if (filter != null) {
                        if (file.getName().matches(filter)) {
                            files.add(file.getAbsolutePath());
                        }
                    } else {
                        files.add(file.getAbsolutePath());
                    }
                } else if (file.isDirectory()) {
                    if (recursive) {
                        listFiles(file.getAbsolutePath(), filter, files, skips, recursive);
                    } else {
                        continue;
                    }
                }
            }
            return true;
        } else {
            return false;
        }
    }

    private static void sleepMillis(final long millis) {
        assert millis > 0;

        try {
            Thread.sleep(millis, 0);
        } catch (final InterruptedException ex) {
            assert false : String.format("Not supposed to interrupt thread '%s'\n", Thread.currentThread().getName());
        }
    }

    private static String getFileNameToDisplay(final String file) {
        assert file != null;

        String displayFileName = file;
        if (displayFileName.length() > 56) {
            displayFileName = "..." + file.substring(file.length() - 56);
        }
        return displayFileName;
    }

    private static long getLastModifiedTime(final Path path) {
        assert path != null;

        try {
            return Files.getLastModifiedTime(path).toMillis();
        } catch (final IOException ex) {
            return -1;
        }
    }

    private static String getTimeStamp(final long millis) {
        final SimpleDateFormat formatter = new SimpleDateFormat("dd.MM.yyyy HH:mm:ss");
        final String date = formatter.format(new Date(millis));
        return date;
    }

    private static boolean isPlatformLinux() {
        return System.getProperty("os.name").equalsIgnoreCase("linux");
    }

    private static String getHash(final String file, final String algorithm) {
        assert file      != null;
        assert algorithm != null;

        if (Config.readSize > 0) { // only read that amount
            try (final FileInputStream in = new FileInputStream(file)) {
                final byte[] buf = new byte[Config.readSize];
                final int readBytes = in.read(buf); // note(nschultz): does NOT block on empty files since EOF is available

                final MessageDigest digest = MessageDigest.getInstance(algorithm);
                final byte[] hash = digest.digest(buf);
                final StringBuilder sHash = new StringBuilder(hash.length);
                for (final byte b : hash) sHash.append(String.format("%02X", b));
                
                return sHash.toString();
            } catch (final Exception ex) {
                System.out.println("ERROR gasai: Failed to retrieve hash value: " + ex.toString());
                System.exit(ERR_HASH);
            }
        } else { // note(nschultz): zero or negative value, so we will read the entire file into memory
            try {
                final byte[] data = Files.readAllBytes(Path.of(file));
                final MessageDigest digest = MessageDigest.getInstance(algorithm);
                final byte[] hash = digest.digest(data);
                final StringBuilder sHash = new StringBuilder(hash.length);
                for (final byte b : hash) sHash.append(String.format("%02X", b));

                return sHash.toString();
            } catch (final Exception ex) {
                System.out.println("ERROR gasai: Failed to retrieve hash value: " + ex.toString());
                System.exit(ERR_HASH);
            }
        }

        assert false : "Unreachable code path.";
        return null; // note(nschultz): will not happen since in case of an error we exit the JVM
    }

    private static CheckResults check() {
        System.out.printf(VT_BOLD + "Checking hashes (%s)..." + VT_RESET + "\n", Config.hash);

        if (!Files.exists(Config.snapshotFile)) {
            System.out.println("No snapshot file found!");
            System.out.println("Did you run 'gasai --update' beforehand?");
            System.exit(ERR_SNAP);
        }

        final StringBuilder log = new StringBuilder(8192);
        log_header: {
            log.append(String.format("TIME      : %s", getTimeStamp(System.currentTimeMillis()))).append("\n");
            log.append(String.format("SNAP      : %s", getTimeStamp(getLastModifiedTime(Config.snapshotFile)))).append("\n");
            log.append(String.format("DIRS      : %s", Arrays.toString(Config.dirs))).append("\n");
            log.append(String.format("MAXSIZEKB : %s", Config.maxSizeKB)).append("\n");
            log.append(String.format("DELAY     : %s", Config.delayMillis)).append("\n");
            log.append(String.format("HASH      : %s", Config.hash)).append("\n");
            log.append(String.format("READSIZE  : %s", Config.readSize)).append("\n");
            log.append("\n\n\n");
        }

        // note(nschultz): have to use these wrappers due to stupid '...must be effectively final' bs.
        final LongAdder processed = new LongAdder();
        final LongAdder changed   = new LongAdder();
        final LongAdder added     = new LongAdder();
        final LongAdder missing   = new LongAdder();

        final LinkedHashMap<String, String> oldSnapshot = new LinkedHashMap<>();
        retrieve_old_snapshot: {
            try {
                final String[] snapshotLines = Files.readString(Config.snapshotFile).split("\n");

                for (int i = 0; i < snapshotLines.length; ++i) {
                    final String line = snapshotLines[i];

                    if (line.split(":").length != 2) continue; // note(nschultz): happens when directory is empty
                    final String file = line.split(":")[0];
                    final String hash = line.split(":")[1];

                    oldSnapshot.put(file, hash);
                }

            } catch (final IOException ex) {
                System.out.println("ERROR gasai: Failed to load snapshot file: " + ex.toString());
                System.exit(ERR_SNAP);
            }
        }

        final ArrayList<String> currentFiles = new ArrayList<>();
        final ArrayList<String> skippedFiles = new ArrayList<>();
        retrieve_current_files: {
            for (int i = 0; i < Config.dirs.length; ++i) {
                final boolean success = listFiles(Config.dirs[i], null, currentFiles, skippedFiles, Config.recursive);
                if (!success) {
                    System.out.printf("ERROR gasai: Failed to list all files in '%s'\n", Config.dirs[i]);
                    System.exit(ERR_LIST);
                }
            }
        }
        processed.add(currentFiles.size());

        // note(nschultz): print all the skipped files first
        for (int i = 0; i < skippedFiles.size(); ++i) {
            final String displayFileName = getFileNameToDisplay(skippedFiles.get(i));
            System.out.printf("  %-59s [ %s ]\n", displayFileName, VT_YELLOW_FG + "SKIP" + VT_RESET);
            log.append(String.format("  %-59s [ %s ]\n", displayFileName, "SKIP"));

            if (Config.delayMillis > 0) {
                sleepMillis(Config.delayMillis);
            }
        }

        compare_old_snapshot_with_current_state: {
            oldSnapshot.forEach((final String file, final String sha) -> {
                final String displayFileName = getFileNameToDisplay(file);

                currentFiles.remove(file);

                if (Files.exists(Path.of(file))) {
                    final String currentHash = getHash(file, Config.hash);

                    if (currentHash.toString().equals(sha)) {
                        if (Config.verbose) System.out.printf("%s\n", currentHash.toString());
                        System.out.printf("  %-59s [ %s ]\n", displayFileName, VT_GREEN_FG + "OK" + VT_RESET);
                        log.append(String.format("  %-59s [ %s ]\n", displayFileName, "OK"));
                    } else {
                        if (Config.verbose) System.out.printf("%s\n", currentHash.toString());
                        System.out.printf("  %-59s [ %s ]\n", displayFileName, VT_RED_FG + "CHANGED" + VT_RESET);
                        log.append(String.format("  %-59s [ %s ]\n", displayFileName, "CHANGED"));
                        changed.increment();
                    }
                } else {
                    System.out.printf("  %-59s [ %s ]\n", displayFileName, VT_RED_FG + "MISSING" + VT_RESET);
                    log.append(String.format("  %-59s [ %s ]\n", displayFileName, "MISSING"));
                    missing.increment();
                }
                if (Config.delayMillis > 0) {
                    sleepMillis(Config.delayMillis);
                }
            });

            // note(nschultz): every file left in this list must be a newly added one, and hence we report it
            for (int i = 0; i < currentFiles.size(); ++i) {
                final String displayFileName = getFileNameToDisplay(currentFiles.get(i));
                System.out.printf("  %-59s [ %s ]\n", displayFileName, VT_RED_FG + "ADDED" + VT_RESET);
                log.append(String.format("  %-59s [ %s ]\n", displayFileName, "ADDED"));
                added.increment();

                if (Config.delayMillis > 0) {
                    sleepMillis(Config.delayMillis);
                }
            }
        }

        write_to_log: {
            try {
                Files.writeString(Config.logFile, log.toString(), StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
            } catch (final IOException ex) {
                System.out.println("Failed to write to log: " + ex.toString());
            }
        }

        return new CheckResults(processed.intValue(),
                                changed.intValue(),
                                added.intValue(),
                                missing.intValue(),
                                skippedFiles.size()
        );
    }

    private static UpdateResults update() {
        System.out.printf(VT_BOLD + "Updating hashes (%s)..." + VT_RESET + "\n", Config.hash);

        final LongAdder fetched                     = new LongAdder();
        final ArrayList<String> files               = new ArrayList<>();
        final ArrayList<String> skippedFiles        = new ArrayList<>();
        final LinkedHashMap<String, String> mapping = new LinkedHashMap<>();

        for (int i = 0; i < Config.dirs.length; ++i) {
            final boolean success = listFiles(Config.dirs[i], null, files, skippedFiles, Config.recursive);
            if (!success) {
                System.out.printf("ERROR gasai: Failed to list all files in '%s'\n", Config.dirs[i]);
                System.exit(ERR_LIST);
            }
        }

        skipped_files: {
            for (int i = 0; i < skippedFiles.size(); ++i) {
                final String displayFileName = getFileNameToDisplay(skippedFiles.get(i));
                System.out.printf("  %-59s [ %s ]\n", displayFileName, VT_YELLOW_FG + "SKIP" + VT_RESET);
                if (Config.delayMillis > 0) {
                    sleepMillis(Config.delayMillis);
                }
            }
        }

        get_sha_hashes: {
            for (final String file : files) {
                final String currentHash = getHash(file, Config.hash);
                mapping.put(file, currentHash);

                final String displayFileName = getFileNameToDisplay(file);

                if (Config.verbose) System.out.printf("%s\n", currentHash);
                System.out.printf("  %-59s [ %s ]\n", displayFileName, VT_GREEN_FG + "FETCHED" + VT_RESET);
                fetched.increment();

                if (Config.delayMillis > 0) {
                    sleepMillis(Config.delayMillis);
                }
            }
        }

        write_to_disk: {
            final StringBuilder dump = new StringBuilder(mapping.size() * 256);
            mapping.forEach((final String file, final String sha) -> {
                dump.append(String.format("%s:%s\n", file, sha));
            });
            try {
                Files.writeString(Config.snapshotFile, dump.toString(), StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
            } catch (final IOException ex) {
                System.out.println("ERROR gasai: Failed to write update result to disk: " + ex.toString());
                System.exit(ERR_SNAP);
            }
        }
        return new UpdateResults(fetched.intValue(), skippedFiles.size());
    }

    private static void printHelp() {
        System.out.printf("gasai v%s - personal security tool for my paranoia\n", VERSION);
        System.out.println();
        System.out.println("Summary");
        System.out.println("=======");
        System.out.println("This command line tool is rather simple, it checks files inside directories for");
        System.out.println("any changes. That includes new files being added, old ones being deleted and");
        System.out.println("any content differences.");
        System.out.println();
        System.out.println("Configuration file");
        System.out.println("==================");
        System.out.println("gasai uses one config file located in your home directory called .gasairc.");
        System.out.println("   dirs=dir1;dir2;          # the directories you wish to check");
        System.out.println("   delaymillis=milliseconds # wait that many ms after each file check");
        System.out.println("   maxsizekb=size_in_kb     # do not check files that are larger than that");
        System.out.println("   verbose=false/true       # print additional information while running");
        System.out.println("   hash=algorithm           # the hash algorithm to use");
        System.out.println("   readsize=size_in_bytes   # how many bytes to use for the hash");
        System.out.println("   snapshotfile=path        # the path of the snapshotfile");
        System.out.println("   logfile=path             # the path of the logfile");
        System.out.println("   recurisve=false/true     # whether you wish to search recursively");
        System.out.println();
        System.out.println("Usage");
        System.out.println("=====");
        System.out.println("gasai [--OPTION]");
        System.out.println("Options:");
        System.out.println("   check   : Check if any hashes have changed since last update run.");
        System.out.println("   update  : Updates all hashes for the specified directories.");
        System.out.println("   init    : Create configuration template.");
        System.out.println("   hashes  : Prints all supported hash algorithms on this platform.");
        System.out.println("   rc      : Loads the configuration and prints the current settings.");
        System.out.println("   snap    : Prints the last update time.");
        System.out.println("   version : Prints the version.");
        System.out.println("   help    : Prints this message.");
        System.out.println();
        System.out.println("Error codes");
        System.out.println("===========");
        System.out.println("ERR_SUCCESS 0");
        System.out.println("ERR_ARGS   -1");
        System.out.println("ERR_TERM   -2");
        System.out.println("ERR_SNAP   -4");
        System.out.println("ERR_LIST   -8");
        System.out.println("ERR_HASH   -16");
        System.out.println("ERR_RC     -32");
        System.out.println("ERR_OS     -64");
        System.out.println("ERR_INIT   -128");
        System.out.println();
        System.out.println("Files");
        System.out.println("=====");
        System.out.println(".gasairc");
        System.out.println(".gasai_hashes");
        System.out.println(".gasai.log");
        System.out.println();
        System.out.println("About");
        System.out.println("=====");
        System.out.println("Developed by Niklas Schultz");
        System.out.println("Copyright (c) 2022 Niklas Schultz");
        System.out.println("Licensed under MIT. See LICENSE file for more details.");
    }

    private static void loadRc() {
        if (Files.notExists(rcFile)) {
            System.out.println("No ~/.gasairc file found.");
            System.out.println("You can use 'gasai --init' to create a default configuration.");
            System.exit(ERR_RC);
        }

        String dirsTemp         = null;
        String delayMillisTemp  = null;
        String maxSizeKBTemp    = null;
        String verboseTemp      = null;
        String hashTemp         = null;
        String readSizeTemp     = null;
        String snapshotFileTemp = null;
        String logFileTemp      = null;
        String recursiveTemp    = null;

        try {
            final String[] lines = Files.readString(rcFile).split("\n");
            for (int i = 0; i < lines.length; ++i) {
                if (lines[i].strip().startsWith("#")) continue; // note(nschultz): skip comments
                if (lines[i].strip().isEmpty())       continue; // note(nschultz): skip empty lines

                final String[] cfg = lines[i].split("=");
                if (cfg.length != 2) {
                    System.out.println("Invalid configuration syntax.");
                    System.exit(ERR_RC);
                }
                final String lhs = cfg[0];
                final String rhs = cfg[1];

                switch (lhs.toLowerCase()) {
                    case "dirs"         : { dirsTemp         = rhs; } break;
                    case "delaymillis"  : { delayMillisTemp  = rhs; } break;
                    case "maxsizekb"    : { maxSizeKBTemp    = rhs; } break;
                    case "verbose"      : { verboseTemp      = rhs; } break;
                    case "hash"         : { hashTemp         = rhs; } break;
                    case "readsize"     : { readSizeTemp     = rhs; } break;
                    case "snapshotfile" : { snapshotFileTemp = rhs; } break;
                    case "logfile"      : { logFileTemp      = rhs; } break;
                    case "recursive"    : { recursiveTemp    = rhs; } break;

                    default: {
                        System.out.println("Error while loading configuration:");
                        System.out.println("Unknown configuration key.");
                        System.out.println("Try running 'gasai --init' to create a default configuration.");
                        System.exit(ERR_RC);
                    } break;
                }
            }
        } catch (final IOException ex) {
            System.out.println("ERROR gasai: Failed to read configuration file.");
            System.exit(ERR_RC);
        }

        check_configuration: {
            dirs: {
                Config.dirs = dirsTemp.split(";");
                for (int j = 0; j < Config.dirs.length; ++j) {
                    if (Files.notExists(Path.of(Config.dirs[j]))) {
                        System.out.println("Error while loading configuration:");
                        System.out.printf("The directory '%s' does not exist. Perhaps you forgot to mount it?\n", Config.dirs[j]);
                        System.exit(ERR_RC);
                    }
                    if (!Files.isDirectory(Path.of(Config.dirs[j]))) {
                        System.out.println("Error while loading configuration:");
                        System.out.printf("'%s' is not a directory.\n", Config.dirs[j]);
                        System.exit(ERR_RC);
                    }
                }
            }

            delayMillis: {
                try {
                    Config.delayMillis = Integer.parseInt(delayMillisTemp);
                    if (Config.delayMillis < 0) {
                        System.out.println("Error while loading configuration:");
                        System.out.println("delaymillis must not be negative.");
                        System.exit(ERR_RC);
                    }
                } catch (final NumberFormatException ex) {
                    System.out.println("Error while loading configuration:");
                    System.out.println("Invalid delaymillis entry. Not a number.");
                    System.exit(ERR_RC);
                }
            }

            maxSizeKB: {
                try {
                    Config.maxSizeKB = Integer.parseInt(maxSizeKBTemp);
                    if (Config.maxSizeKB < 0) {
                        System.out.println("Error while loading configuration:");
                        System.out.println("maxsizekb must not be negative.");
                        System.exit(ERR_RC);
                    }
                } catch (final NumberFormatException ex) {
                    System.out.println("Error while loading configuration:");
                    System.out.println("Invalid maxsizekb entry. Not a number.");
                    System.exit(ERR_RC);
                }
            }

            verbose: {
                Config.verbose = Boolean.parseBoolean(verboseTemp);
            }

            hash: {
                Config.hash = hashTemp;

                final Set<String> algorithms = Security.getAlgorithms("MessageDigest");
                // linear search
                boolean supported = false;
                for (final String algorithm : algorithms) {
                    if (algorithm.equals(Config.hash)) {
                        supported = true;
                    }
                }
                if (!supported) {
                    System.out.println("Error while loading configuration:");
                    System.out.printf("Unsupported or unknown hash algorithm '%s'\n", Config.hash);
                    System.exit(ERR_RC);
                }
            }

            readSize: {
                try {
                    Config.readSize = Integer.parseInt(readSizeTemp);
                } catch (final NumberFormatException ex) {
                    System.out.println("Error while loading configuration:");
                    System.out.println("Invalid readSize entry. Not a number!");
                    System.exit(ERR_RC);
                }
            }

            snapshotFile: {
                try {
                    Config.snapshotFile = Path.of(snapshotFileTemp);
                    if (Files.isDirectory(Config.snapshotFile)) {
                        System.out.println("Error while loading configuration:");
                        System.out.println("Bad snapshot file path; must not be directory.");
                        System.exit(ERR_RC);
                    }
                } catch (final Exception ex) {
                    System.out.println("Error while loading configuration:");
                    System.out.println("Bad snapshot file path.");
                    System.exit(ERR_RC);
                }
            }

            logfile: {
                try {
                    Config.logFile = Path.of(logFileTemp);
                    if (Files.isDirectory(Config.logFile)) {
                        System.out.println("Error while loading configuration:");
                        System.out.println("Bad logfile path; must not be directory.");
                        System.exit(ERR_RC);
                    }
                } catch (final Exception ex) {
                    System.out.println("Error while loading configuration:");
                    System.out.println("Bad logfile path.");
                    System.exit(ERR_RC);
                }
            }

            recursive: {
                Config.recursive = Boolean.parseBoolean(recursiveTemp);
            }
        }
    }

    private static void init() {
        System.out.println("Creating new configuration...");
        try {
            if (Files.exists(rcFile)) {
                Files.delete(rcFile);
            }

            default_values: {
                // note(nschultz): '/usr/bin/' is a good default I think because it probably is the first thing malware (e.g a rootkits) might
                // tamper with in order to make it undectable.
                Config.dirs         = new String[] {isPlatformLinux() ? "/usr/bin/" : System.getProperty("user.home")};
                Config.delayMillis  = 3;
                Config.maxSizeKB    = 8192;
                Config.verbose      = false;
                Config.hash         = "SHA-256";
                Config.readSize     = 0;
                // note(nschultz): it is good to make these configurable for several reason besides given the user
                // the possiblity two have mutliple versions of a snapshot file.
                // One reason is that it might be a bit harder for malware to detect the snapshot file (by name
                // at least) and mess with it.
                Config.snapshotFile = Path.of(System.getProperty("user.home"), ".gasai_hashes");
                Config.logFile      = Path.of(System.getProperty("user.home"), ".gasai.log");
                Config.recursive    = false;
            }

            final StringBuilder buffer = new StringBuilder();
            buffer.append("# ").append("\n");
            buffer.append("# ").append("\n");
            buffer.append("# ").append("\n");
            buffer.append("# Configuration file ").append("\n");
            buffer.append("# gasai ").append(VERSION).append("\n");
            buffer.append("# ").append("\n");
            buffer.append("# ").append("\n");
            buffer.append("# ").append("\n");
            buffer.append("\n\n\n");

            buffer.append("# the directories you wish to check separated by a semicolon").append("\n");
            buffer.append("dirs=");
            for (final String dir : Config.dirs) buffer.append(dir + ";");
            buffer.append("\n");

            buffer.append("# wait time in milliseconds before each file check").append("\n");
            buffer.append("delaymillis=").append(String.valueOf(Config.delayMillis)).append("\n");

            buffer.append("# do not check files which are bigger than this size").append("\n");
            buffer.append("maxSizekb=").append(String.valueOf(Config.maxSizeKB)).append("\n");

            buffer.append("# true or false depending on whether you wish to print verbose information").append("\n");
            buffer.append("verbose=").append(String.valueOf(Config.verbose)).append("\n");

            buffer.append("# the hash algorithm").append("\n");
            buffer.append("hash=").append(String.valueOf(Config.hash)).append("\n");

            buffer.append("# how many bytes are read from each file for the hash").append("\n");
            buffer.append("readsize=").append(String.valueOf(Config.readSize)).append("\n");

            buffer.append("# the path of the snapshotfile").append("\n");
            buffer.append("snapshotfile=").append(String.valueOf(Config.snapshotFile)).append("\n");

            buffer.append("# the path of the logfile").append("\n");
            buffer.append("logfile=").append(String.valueOf(Config.logFile)).append("\n");

            buffer.append("# whether you wish to search recursively").append("\n");
            buffer.append("recursive=").append(String.valueOf(Config.recursive)).append("\n");

            Files.writeString(rcFile, buffer.toString());

            System.out.println("New configuration has been created.");
        } catch (final IOException ex) {
            System.out.println("Failed to init: " + ex.toString());
            System.exit(ERR_INIT);
        }
    }

    private static void printHeader() {
        System.out.printf(VT_BOLD + VT_PURPLE_FG + "[ gasai %s ]\n" + VT_RESET, "version " + VERSION);
        System.out.println();
        sleepMillis(1500);
    }

    public static void main(final String[] args) {
        check_os: {
            if (!isPlatformLinux()) {
                System.out.println("gasai is not supported on a non Linux operating system right now.");
                System.exit(ERR_OS);
            }
        }

        check_temrinal_size: {
            if (System.getProperty("os.name").toLowerCase().equals("linux")) {
                if (Integer.parseInt(execShellCommandWait("tput lines").strip()) < 25) {
                    System.out.println("gasai requires a minimum of 25 terminal lines.");
                    System.exit(ERR_TERM);
                }
                if (Integer.parseInt(execShellCommandWait("tput cols").strip()) < 80) {
                    System.out.println("gasai requires a minimum of 80 terminal cols.");
                    System.exit(ERR_TERM);
                }
            }
        }

        if (args.length == 0) {
            System.out.println("No arguments provided.");
            System.out.println("Try running gasai with '--help'.");
            System.exit(ERR_ARGS);
        }

        if (args.length == 1) {
            final String option = args[0];

            switch (option) {
                case "--check": {
                    printHeader();
                    loadRc();

                    final double startTime = (double) System.nanoTime();

                    final CheckResults results = check();
                    System.out.println();

                    if (Config.dirs.length == 1) {
                        System.out.printf("gasai has scanned %s directory.\n", Config.dirs.length);
                    } else {
                        System.out.printf("gasai has scanned %s directories.\n", Config.dirs.length);
                    }
                    System.out.println();
                    System.out.println("Results:");
                    System.out.println("  Processed files: " + results.processed);
                    System.out.println("  Skipped   files: " + results.skips);
                    System.out.println("  Changed   files: " + results.changed);
                    System.out.println("  Added     files: " + results.added);
                    System.out.println("  Missing   files: " + results.missing);

                    final double endTime = (double) System.nanoTime();
                    final double elapsedTime = (double) (endTime - startTime) / 1000000000.0d;
                    System.out.println();
                    System.out.printf("Total elapsed time %.1f seconds\n", elapsedTime);
                } break;

                case "--update": {
                    printHeader();
                    loadRc();

                    final double startTime = (double) System.nanoTime();
                    final UpdateResults result = update();
                    System.out.println();
                    if (result.processed == 1) {
                        System.out.printf("gasai has updated '%s' hash.\n", result.processed);
                    } else {
                        System.out.printf("gasai has updated '%s' hashes.\n", result.processed);
                    }

                    final double endTime = (double) System.nanoTime();
                    final double elapsedTime = (double) (endTime - startTime) / 1000000000.0d;
                    System.out.printf("Total elapsed time %.1f seconds\n", elapsedTime);
                } break;

                case "--init": {
                    printHeader();

                    init();
                } break;

                case "--hashes": {
                    printHeader();

                    System.out.println("The following hash algorithms are supported on this platform:");
                    final Set<String> algorithms = Security.getAlgorithms("MessageDigest");
                    for (final String algorithm : algorithms) {
                        System.out.println("  " + algorithm);
                    }
                } break;

                case "--rc": {
                    printHeader();

                    loadRc();
                    System.out.println(rcFile.toString());
                    for (int i = 0; i < Config.dirs.length; ++i) System.out.printf("  Dir%s         : %s\n", i + 1, Config.dirs[i]);
                    System.out.printf("  delaymillis  : %s\n", Config.delayMillis);
                    System.out.printf("  maxsizekb    : %s\n", Config.maxSizeKB);
                    System.out.printf("  verbose      : %s\n", Config.verbose);
                    System.out.printf("  hash         : %s\n", Config.hash);
                    System.out.printf("  readsize     : %s\n", Config.readSize);
                    System.out.printf("  snapshotfile : %s\n", Config.snapshotFile);
                    System.out.printf("  logfile      : %s\n", Config.logFile);
                    System.out.printf("  recursive    : %s\n", Config.recursive);
                } break;

                case "--snap": {
                    printHeader();
                    loadRc();

                    final long millis = getLastModifiedTime(Config.snapshotFile);
                    if (millis < 0) {
                        System.out.println("Failed to retrieve last update time.");
                        System.out.println("Perhaps you have no snapshot file yet?");
                        System.out.println("If that is the case try running 'gasai --update'");
                        System.exit(ERR_SNAP);
                    }
                    final String lastUpdateTime = getTimeStamp(millis);
                    System.out.println(Config.snapshotFile.toString());
                    System.out.println("  " + lastUpdateTime);
                } break;

                case "--help": {
                    printHelp();
                } break;

                case "--version": {
                    System.out.println(VERSION);
                } break;

                default: {
                    System.out.printf("Unknown argument '%s'\n", option);
                    System.out.println("Try running gasai with '--help'.");
                    System.exit(ERR_ARGS);
                } break;
            }
        } else {
            System.out.println("Too many arguments.");
            System.out.println("Try running gasai with '--help'.");
            System.exit(ERR_ARGS);
        }

        System.exit(ERR_SUCCESS);
    }
}
