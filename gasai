#!/usr/bin/java --source 17

//                        _ 
//                       (_)
//   __ _  __ _ ___  __ _ _ 
//  / _` |/ _` / __|/ _` | |
// | (_| | (_| \__ \ (_| | |
//  \__, |\__,_|___/\__,_|_|
//   __/ |                  
//  |___/                   
//             - Niklas Schultz
//
//
// gasai - personal "security" tool for my paranoia :)
//

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.security.MessageDigest;
import java.security.Security;
import java.util.ArrayList;
import java.util.Date;
import java.util.LinkedHashMap;
import java.util.Set;
import java.util.concurrent.atomic.LongAdder;

public final class gasai {

    private static final String VERSION = "0.1.0";

    private static final String VT_RESET     = "\u001B[0m";
    private static final String VT_BOLD      = "\u001B[1m";
    private static final String VT_RED_FG    = "\u001B[31m";
    private static final String VT_GREEN_FG  = "\u001B[32m";
    private static final String VT_PURPLE_FG = "\u001B[35m";

    private static final int ERR_SUCCESS = 0;
    private static final int ERR_ARGS    = -1;
    private static final int ERR_TERM    = -2;
    private static final int ERR_SNAP    = -4;
    private static final int ERR_LIST    = -8;
    private static final int ERR_HASH    = -16;
    private static final int ERR_RC      = -32;
    private static final int ERR_OS      = -64;
    private static final int ERR_INIT    = -128;
    
    // todo(nschultz): This location should be configurable by using the rc file.
    // rc file should probably be located in the same directory as the gasai script
    // itself. That way you can have this run on separate hard drives (profiles basically).
    private static final Path snapshotFile = Path.of(System.getProperty("user.home"), ".gasai_hashes");
    private static final Path rcFile       = Path.of(System.getProperty("user.home"), ".gasairc");
    private static final Path logFile      = Path.of(System.getProperty("user.home"), ".gasai.log");

    private static final class Config {
        private Config() { assert false; }

        public static String[] dirs   = null;
        public static int delayMillis = 0;
        public static int maxSizeKB   = 0;
        public static boolean verbose = false;
        public static String hash     = null;
    }

    private static final class CheckResults {
        public final int changed;
        public final int added;
        public final int missing;

        public CheckResults(final int changed, final int added, final int missing) {
            this.changed = changed;
            this.added   = added;
            this.missing = missing;
        }
    }

    private static String execShellCommandWait(final String cmdLine) {
        try {
            final Process process = Runtime.getRuntime().exec(cmdLine);
            process.waitFor();

            final int exitValue = process.exitValue();
            if (exitValue == 0) {
                final InputStream in = process.getInputStream();
                final StringBuilder result = new StringBuilder();
                for (;;) {
                    final byte[] buf = new byte[4096];
                    final int readBytes = in.read(buf);
                    if (readBytes < 0) {
                        return result.toString();
                    }
                    result.append(new String(buf, 0, readBytes, StandardCharsets.UTF_8));
                }
            } else {
                final InputStream in = process.getErrorStream();
                final StringBuilder result = new StringBuilder();
                for (;;) {
                    final byte[] buf = new byte[4096];
                    final int readBytes = in.read(buf);
                    if (readBytes < 0) {
                        return result.toString();
                    }
                    result.append(new String(buf, 0, readBytes, StandardCharsets.UTF_8));
                }
            }
        } catch (final IOException ex) {
            return null;
        } catch (final InterruptedException ex) {
            assert false : String.format("Not supposed to interrupt thread '%s'");
            return null;
        }
    }

    private static boolean listFiles(final String start, final String filter, final ArrayList<String> files) {
        assert start  != null;
        assert filter != null;
        assert files  != null;

        final File directory = new File(start);
        final File[] list = directory.listFiles();
        if (list != null) {
            for (final File file : list) {
                if (file.getName().equals("X11"))              continue; // Hack for Linux
                if ((file.length() / 1024) > Config.maxSizeKB) continue; // prevent possible OOM

                if (file.isFile()) {
                    if (filter != null) {
                        if (file.getName().matches(filter)) {
                            files.add(file.getAbsolutePath());
                        }
                    } else {
                        files.add(file.getAbsolutePath());
                    }
                } else if (file.isDirectory()) {
                    listFiles(file.getAbsolutePath(), filter, files);
                }
            }
            return true;
        } else {
            return false;
        }
    }

    private static void sleepMillis(final long millis) {
        assert millis > 0;

        try {
            Thread.sleep(millis, 0);
        } catch (final InterruptedException ex) {
            assert false : String.format("Not supposed to interrupt thread '%s'\n", Thread.currentThread().getName());
        }
    }

    private static String getFileNameToDisplay(final String file) {
        assert file != null;

        String displayFileName = file;
        if (displayFileName.length() > 60) {
            displayFileName = "..." + file.substring(file.length() - 56);
        }
        return displayFileName;
    }

    private static String getHash(final String file, final String algorithm) {
        assert file      != null;
        assert algorithm != null;

        try {
            final byte[] data = Files.readAllBytes(Path.of(file));
            final MessageDigest digest = MessageDigest.getInstance(algorithm);
            final byte[] hash = digest.digest(data);
            final StringBuilder sHash = new StringBuilder(hash.length);
            for (final byte b : hash) sHash.append(String.format("%02X", b));

            return sHash.toString();
        } catch (final Exception ex) {
            System.out.println("ERROR gasai: Failed to retrieve hash value: " + ex.toString());
            System.exit(ERR_HASH);
        }

        assert false : "Should have exit JVM instead of reaching this code path.";
        return null; // will not happen since in case of an error we exit the JVM
    }

    private static CheckResults check() {
        System.out.println();
        System.out.printf(VT_BOLD + "Checking hashes (%s)..." + VT_RESET + "\n", Config.hash);

        final StringBuilder log = new StringBuilder(8192);
        log.append(" [ " + new Date() + " ] ").append("\n\n\n");
        log.append(String.format(" [ Using %s ]\n", Config.hash));

        // have to use these wrappers due to stupid '...must be effectively final' bs.
        final LongAdder changed = new LongAdder();
        final LongAdder added   = new LongAdder();
        final LongAdder missing = new LongAdder();

        final LinkedHashMap<String, String> oldSnapshot = new LinkedHashMap<>();
        retrieve_old_snapshot: {
            if (!Files.exists(snapshotFile)) {
                System.out.println("No snapshot file found!");
                System.out.println("Did you run 'gasai --update' beforehand?");
                System.exit(ERR_SNAP);
            }

            try {
                final String[] snapshotLines = Files.readString(snapshotFile).split("\n");

                for (int i = 0; i < snapshotLines.length; ++i) {
                    final String line = snapshotLines[i];

                    if (line.split(":").length != 2) continue; // happens when directory is empty
                    final String file = line.split(":")[0];
                    final String hash = line.split(":")[1];

                    oldSnapshot.put(file, hash);
                }

            } catch (final IOException ex) {
                System.out.println("ERROR gasai: Failed to load snapshot file: " + ex.toString());
                System.exit(ERR_SNAP);
            }
        }

        final ArrayList<String> currentFiles = new ArrayList<>();
        retrieve_current_files: {
            for (int i = 0; i < Config.dirs.length; ++i) {
                final boolean success = listFiles(Config.dirs[i], null, currentFiles);
                if (!success) {
                    System.out.printf("ERROR gasai: Failed to list all files in '%s'\n", Config.dirs[i]);
                    System.exit(ERR_LIST);
                }
            }
        }

        compare_old_snapshot_with_current_state: {
            oldSnapshot.forEach((final String file, final String sha) -> {
                final String displayFileName = getFileNameToDisplay(file);

                currentFiles.remove(file);

                if (Files.exists(Path.of(file))) {
                    final String currentHash = getHash(file, Config.hash);

                    if (currentHash.toString().equals(sha)) {
                        if (Config.verbose) System.out.printf("%s\n", currentHash.toString());
                        System.out.printf("  %-59s [ %s ]\n", displayFileName, VT_GREEN_FG + "OK" + VT_RESET);
                        log.append(String.format("  %-59s [ %s ]\n", displayFileName, VT_GREEN_FG + "OK" + VT_RESET));
                    } else {
                        if (Config.verbose) System.out.printf("%s\n", currentHash.toString());
                        System.out.printf("  %-59s [ %s ]\n", displayFileName, VT_RED_FG + "CHANGED" + VT_RESET);
                        log.append(String.format("  %-59s [ %s ]\n", displayFileName, VT_RED_FG + "CHANGED" + VT_RESET));
                        changed.increment();
                    }
                } else {
                    System.out.printf("  %-59s [ %s ]\n", displayFileName, VT_RED_FG + "MISSING" + VT_RESET);
                    log.append(String.format("  %-59s [ %s ]\n", displayFileName, VT_RED_FG + "MISSING" + VT_RESET));
                    missing.increment();
                }
                if (Config.delayMillis > 0) {
                    sleepMillis(Config.delayMillis);
                }
            });

            // every file left in this list must be a newly added one, and hence we report it
            for (int i = 0; i < currentFiles.size(); ++i) {
                final String displayFileName = getFileNameToDisplay(currentFiles.get(i));
                System.out.printf("  %-59s [ %s ]\n", displayFileName, VT_RED_FG + "ADDED" + VT_RESET);
                log.append(String.format("  %-59s [ %s ]\n", displayFileName, VT_RED_FG + "ADDED" + VT_RESET));
                added.increment();

                if (Config.delayMillis > 0) {
                    sleepMillis(Config.delayMillis);
                }
            }
        }

        write_to_log: {
            try {
                Files.writeString(logFile, log.toString(), StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
            } catch (final IOException ex) {
                System.out.println("Failed to write to log: " + ex.toString());
            }
        }

        return new CheckResults(changed.intValue(), added.intValue(), missing.intValue());
    }

    private static int update() {
        System.out.println();
        System.out.printf(VT_BOLD + "Updating hashes (%s)..." + VT_RESET + "\n", Config.hash);

        final LongAdder fetched = new LongAdder();
        files: {
            final ArrayList<String> files = new ArrayList<>();
            final LinkedHashMap<String, String> mapping = new LinkedHashMap<>();

            for (int i = 0; i < Config.dirs.length; ++i) {
                final boolean success = listFiles(Config.dirs[i], null, files);
                if (!success) {
                    System.out.printf("ERROR gasai: Failed to list all files in '%s'\n", Config.dirs[i]);
                    System.exit(ERR_LIST);
                }
            }

            get_sha_hashes: {
                for (final String file : files) {
                    final String currentHash = getHash(file, Config.hash);
                    mapping.put(file, currentHash);

                    final String displayFileName = getFileNameToDisplay(file);

                    if (Config.verbose) System.out.printf("%s\n", currentHash);
                    System.out.printf("  %-59s [ %s ]\n", displayFileName, VT_GREEN_FG + "FETCHED" + VT_RESET);
                    fetched.increment();

                    if (Config.delayMillis > 0) {
                        sleepMillis(Config.delayMillis);
                    }
                }
            }

            write_to_disk: {
                final StringBuilder dump = new StringBuilder(mapping.size() * 256);
                mapping.forEach((final String file, final String sha) -> {
                    dump.append(String.format("%s:%s\n", file, sha));
                });
                try {
                    Files.writeString(snapshotFile, dump.toString(), StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
                } catch (final IOException ex) {
                    System.out.println("ERROR gasai: Failed to write update result to disk: " + ex.toString());
                    System.exit(ERR_SNAP);
                }
            }
        }
        return fetched.intValue();
    }

    private static void printHelp() {
        System.out.printf("gasai v%s - personal security tool for my paranoia\n", VERSION);
        System.out.println();
        System.out.println("Summary");
        System.out.println("=======");
        System.out.println("This command line tool is rather simple, it checks files inside directories for");
        System.out.println("any changes. That includes new files being added, old ones being deleted and");
        System.out.println("any content differences.");
        System.out.println();
        System.out.println("Configuration file");
        System.out.println("==================");
        System.out.println("gasai uses one config file located in your home directory called .gasairc.");
        System.out.println("   dirs=dir1;dir2;           # the directories you wish to check");
        System.out.println("   delaymillis=milliseconds; # wait that many ms after each file check");
        System.out.println("   maxsizekb=size_in_kb;     # do not check files that are larger than that");
        System.out.println("   verbose=false/true;       # print additional information while running");
        System.out.println("   hash=algorithm;           # the hash algorithm to use");
        System.out.println();
        System.out.println("Usage");
        System.out.println("=====");
        System.out.println("   gasai [--OPTION]");
        System.out.println("Options:");
        System.out.println("   check   : Check if any hashes have changed since last update run.");
        System.out.println("   update  : Updates all hashes for the specified directories.");
        System.out.println("   init    : Deletes the rc file and recreates it with default values.");
        System.out.println("   hashes  : Prints all supported hash algorithms on this platform.");
        System.out.println("   version : Prints the version.");
        System.out.println("   help    : Prints this message.");
        System.out.println();
        System.out.println("Error codes");
        System.out.println("===========");
        System.out.println("   ERR_SUCCESS 0");
        System.out.println("   ERR_ARGS   -1");
        System.out.println("   ERR_TERM   -2");
        System.out.println("   ERR_SNAP   -4");
        System.out.println("   ERR_LIST   -8");
        System.out.println("   ERR_HASH   -16");
        System.out.println("   ERR_RC     -32");
        System.out.println("   ERR_OS     -64");
        System.out.println("   ERR_INIT   -128");
        System.out.println();
        System.out.println("About");
        System.out.println("=====");
        System.out.println("Developed by Niklas Schultz");
        System.out.println("Copyright (c) 2022 Niklas Schultz");
        System.out.println("Licensed under MIT. See LICENSE file for more details.");
    }

    private static void loadRc() {
        if (Files.notExists(rcFile)) {
            System.out.println("No ~/.gasairc file found.");
            System.out.println("You can use 'gasai --init' to create a default configuration.");
            System.exit(ERR_RC);
        }

        try {
            final String[] lines = Files.readString(rcFile).split("\n");
            for (int i = 0; i < lines.length; ++i) {
                if (lines[i].strip().startsWith("#")) continue; // skip comments
                if (lines[i].strip().isEmpty())       continue; // skip empty lines

                final String[] cfg = lines[i].split("=");
                if (cfg.length != 2) {
                    System.out.println("Invalid configuration syntax.");
                    System.exit(ERR_RC);
                }
                final String lhs = cfg[0];
                final String rhs = cfg[1];

                switch (lhs.toLowerCase()) {
                    case "dirs": {
                        final String[] dirs = rhs.split(";");
                        Config.dirs = dirs;

                        for (int j = 0; j < Config.dirs.length; ++j) {
                            if (Files.notExists(Path.of(Config.dirs[j]))) {
                                System.out.printf("The directory '%s' does not exist. Perhaps you forgot to mount it?\n", Config.dirs[j]);
                                System.exit(ERR_RC);
                            }
                            if (!Files.isDirectory(Path.of(Config.dirs[j]))) {
                                System.out.printf("'%s' is not a directory.\n", Config.dirs[j]);
                                System.exit(ERR_RC);
                            }
                        }
                    } break;

                    case "delaymillis": {
                        try {
                            Config.delayMillis = Integer.parseInt(rhs);
                        } catch (final NumberFormatException ex) {
                            System.out.println("Invalid delaymillis entry. Not a number!");
                            System.exit(ERR_RC);
                        }
                    } break;

                    case "maxsizekb": {
                        try {
                            Config.maxSizeKB = Integer.parseInt(rhs);
                        } catch (final NumberFormatException ex) {
                            System.out.println("Invalid maxsizekb entry. Not a number!");
                            System.exit(ERR_RC);
                        }
                    } break;

                    case "verbose": {
                        Config.verbose = Boolean.parseBoolean(rhs);
                    } break;

                    case "hash": {
                        Config.hash = rhs;
                        final Set<String> algorithms = Security.getAlgorithms("MessageDigest");
                        // linear search
                        boolean supported = false;
                        for (final String algorithm : algorithms) {
                            if (algorithm.equals(Config.hash)) {
                                supported = true;
                            }
                        }
                        if (!supported) {
                            System.out.printf("Unsupported or unknown hash algorithm '%s'\n", Config.hash);
                            System.exit(ERR_RC);
                        }
                    } break;

                    default: {
                        System.out.println("Unknown configuration key.");
                        System.out.println("Try running 'gasai --init' to create a default configuration.");
                        System.exit(ERR_RC);
                    } break;
                }
            }
        } catch (final IOException ex) {
            System.out.println("ERROR gasai: Failed to load configuration file.");
            System.exit(ERR_RC);
        }
    }

    private static void init() {
        System.out.println("Creating new configuration...");
        try {
            if (Files.exists(rcFile)) {
                Files.delete(rcFile);
            }

            // default values
            Config.dirs        = new String[] {System.getProperty("user.home")};
            Config.delayMillis = 3;
            Config.maxSizeKB   = 8192;
            Config.verbose     = false;
            Config.hash        = "SHA-256";

            final StringBuilder buffer = new StringBuilder();
            buffer.append("# ").append("\n");
            buffer.append("# ").append("\n");
            buffer.append("# ").append("\n");
            buffer.append("# Configuration file ").append("\n");
            buffer.append("# gasai ").append(VERSION).append("\n");
            buffer.append("# ").append("\n");
            buffer.append("# ").append("\n");
            buffer.append("# ").append("\n");
            buffer.append("\n\n\n");

            buffer.append("# the directories you wish to check separated by a semicolon").append("\n");
            buffer.append("dirs=").append(System.getProperty("user.home")).append("\n");
            buffer.append("# wait time in milliseconds before each file check").append("\n");
            buffer.append("delaymillis=").append(String.valueOf(Config.delayMillis)).append("\n");
            buffer.append("# do not check files which are bigger than this size").append("\n");
            buffer.append("maxSizekb=").append(String.valueOf(Config.maxSizeKB)).append("\n");
            buffer.append("# true or false depending on whether you wish to print verbose information").append("\n");
            buffer.append("verbose=").append(String.valueOf(Config.verbose)).append("\n");
            buffer.append("# the hash algorithm").append("\n");
            buffer.append("hash=").append(String.valueOf(Config.hash)).append("\n");

            Files.writeString(rcFile, buffer.toString());

            if (Files.exists(snapshotFile)) {
                Files.delete(snapshotFile);
            }

            if (Files.exists(logFile)) {
                Files.delete(logFile);
            }

            System.out.println("New configuration has been created.");
        } catch (final IOException ex) {
            System.out.println("Failed to init: " + ex.toString());
            System.exit(ERR_INIT);
        }
    }

    public static void main(final String[] args) {
        check_os: {
            // todo(nschultz): change that! Actually I don't think we need this. This script should run just fine
            // on Windows...but we have not tested that so...
            if (!System.getProperty("os.name").toLowerCase().equals("linux")) {
                System.out.println("gasai is not supported on a non Linux operating system right now.");
                System.exit(ERR_OS);
            }
        }

        check_temrinal_size: {
            if (System.getProperty("os.name").toLowerCase().equals("linux")) {
                if (Integer.parseInt(execShellCommandWait("tput lines").strip()) < 25) {
                    System.out.println("gasai requires a minimum of 25 terminal lines.");
                    System.exit(ERR_TERM);
                }
                if (Integer.parseInt(execShellCommandWait("tput cols").strip()) < 80) {
                    System.out.println("gasai requires a minimum of 80 terminal cols.");
                    System.exit(ERR_TERM);
                }
            }
        }

        if (args.length == 0) {
            System.out.println("No arguments provided.");
            System.out.println("Try running gasai with '--help'.");
            System.exit(ERR_ARGS);
        }

        if (args.length == 1) {
            final String option = args[0];

            switch (option) {
                case "--check": {
                    System.out.printf(VT_BOLD + VT_PURPLE_FG + "[ gasai %s ]\n" + VT_RESET, "version " + VERSION);
                    sleepMillis(2000);
                    loadRc();

                    final double startTime = (double) System.nanoTime();

                    final CheckResults results = check();

                    System.out.println();
                    if (Config.dirs.length == 1) {
                        System.out.printf("gasai has scanned %s directory.\n", Config.dirs.length);
                    } else {
                        System.out.printf("gasai has scanned %s directories.\n", Config.dirs.length);
                    }
                    System.out.println();
                    System.out.println("Results:");
                    System.out.println("  Changed files: " + results.changed);
                    System.out.println("  Added   files: " + results.added);
                    System.out.println("  Missing files: " + results.missing);

                    final double endTime = (double) System.nanoTime();
                    final double elapsedTime = (double) (endTime - startTime) / 1000000000.0d;
                    System.out.println();
                    System.out.printf("Total elapsed time %.1f seconds\n", elapsedTime);
                } break;

                case "--update": {
                    System.out.printf(VT_BOLD + VT_PURPLE_FG + "[ gasai %s ]\n" + VT_RESET, "version " + VERSION);
                    sleepMillis(2000);
                    loadRc();

                    final double startTime = (double) System.nanoTime();
                    final int fetched = update();
                    System.out.println();
                    if (fetched == 1) {
                        System.out.printf("gasai has updated '%s' hash.\n", fetched);
                    } else {
                        System.out.printf("gasai has updated '%s' hashes.\n", fetched);
                    }

                    final double endTime   = (double) System.nanoTime();
                    final double elapsedTime = (double) (endTime - startTime) / 1000000000.0d;
                    System.out.printf("Total elapsed time %.1f seconds\n", elapsedTime);
                } break;

                case "--init": {
                    init();
                } break;

                case "--hashes": {
                    System.out.println("The following hash algorithms are supported on this platform:");
                    final Set<String> algorithms = Security.getAlgorithms("MessageDigest");
                    for (final String algorithm : algorithms) {
                        System.out.println("  " + algorithm);
                    }
                } break;

                case "--help": {
                    printHelp();
                } break;

                case "--version": {
                    System.out.println(VERSION);
                } break;

                default: {
                    System.out.printf("Unknown argument '%s'\n", option);
                    System.out.println("Try running gasai with '--help'.");
                    System.exit(ERR_ARGS);
                } break;
            }
        } else {
            System.out.println("Too many arguments.");
            System.out.println("Try running gasai with '--help'.");
            System.exit(ERR_ARGS);
        }

        System.exit(ERR_SUCCESS);
    }
}
