#!/usr/bin/java --source 17

//                        _ 
//                       (_)
//   __ _  __ _ ___  __ _ _ 
//  / _` |/ _` / __|/ _` | |
// | (_| | (_| \__ \ (_| | |
//  \__, |\__,_|___/\__,_|_|
//   __/ |                  
//  |___/                   
//             - Niklas Schultz
//
//
// gasai - personal "security" tool for my paranoia :)
//

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.security.MessageDigest;
import java.security.Security;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.LinkedHashMap;
import java.util.Scanner;
import java.util.Set;
import java.util.concurrent.atomic.LongAdder;

// todo(nschultz): Sort files alphabetically before processing
// java.util.Collections.sort(list)
//
// todo(nschultz): What happens when we set a maxsize limit to, say 3 megabytes, and the file gets changed afterwards to a size
// bigger than this limit? Well, it will get marked with skipped but is that really what we want in this case?
//
// todo(nschultz): Option to skip non present directories (e.g if they are not yet mounted, or connected)
//
// todo(nschultz): What happens if recursive is configured and you specificy another subdirectory
//
// todo(nschultz): Print directory and then the files it contains
//
// todo(nschultz): Configuration filtering (extension, file-type, etc)
//
// todo(nschultz): listFiles() should return map (dirname, list<files>)
//
// todo(nschultz): Maybe it would be better if we group the checks (e.g first change for changes, then for missing files and
// then for added files. Also skipped files.
//
// todo(nschultz): If a filename contains special characters (e.g kanji) than
// String.length() might "incorrect" value. This causes the formatting (max 80 chars)
// to be wrong.
//
// todo(nschultz): Rot13 the .gasai_hashes files if Config.rot13 is true. This way it makes the hash values less transparent and
// in case of malware which checks files for hahses more secure. Because if the malware decides to change the hashes in the file
// to avoid detection it would be wrong since it gets shuffled on gasai --check call.
//
// todo(nschultz): Config.files -> same as Config.dirs but specific files you want to check
//
// todo(nschultz): Make README file more useful. Add howto (e.g put hash file on usb stick for best practice)
//
// todo(nschultz): Keep a history (multiple log files)
public final class gasai {

    private static final String VERSION = "0.1.0";

    private static final String VT_RESET     = "\u001B[0m";
    private static final String VT_BOLD      = "\u001B[1m";
    private static final String VT_RED_FG    = "\u001B[31m";
    private static final String VT_GREEN_FG  = "\u001B[32m";
    private static final String VT_YELLOW_FG = "\u001B[33m";
    private static final String VT_PURPLE_FG = "\u001B[35m";

    private static final int ERR_SUCCESS =  0;
    private static final int ERR_ARGS    = -1;
    private static final int ERR_TERM    = -2;
    private static final int ERR_SNAP    = -4;
    private static final int ERR_LIST    = -8;
    private static final int ERR_HASH    = -16;
    private static final int ERR_RC      = -32;
    private static final int ERR_INIT    = -64;

    private static final class Config {
        private Config() { assert false; }

        public static String[] dirs           = null;
        public static int delayMillis         = 0;
        public static int maxSizeKB           = 0;
        public static boolean verbose         = false;
        public static String hash             = null;
        public static int readSize            = 0;
        public static Path snapshotFile       = null;
        public static Path logFile            = null;
        public static boolean recursive       = false;
        public static int bufSize             = 0;
        public static boolean snapTamperCheck = false;
    }

    private static final class CheckResults {
        public final int processed;
        public final int changed;
        public final int added;
        public final int missing;
        public final int skips;
        public final int dirsChecked;

        public CheckResults(final int processed, final int changed, final int added, final int missing, final int skips, final int dirsChecked) {
            this.processed   = processed;
            this.changed     = changed;
            this.added       = added;
            this.missing     = missing;
            this.skips       = skips;
            this.dirsChecked = dirsChecked;
        }
    }

    private static final class UpdateResults {
        public final int processed;
        public final int skips;

        public UpdateResults(final int processed, final int skips) {
            this.processed = processed;
            this.skips     = skips;
        }
    }

    private static String execShellCommandWait(final String cmdLine) {
        try {
            final Process process = Runtime.getRuntime().exec(cmdLine);
            process.waitFor();

            final int exitValue = process.exitValue();
            if (exitValue == 0) {
                final InputStream in = process.getInputStream();
                final StringBuilder result = new StringBuilder();
                for (;;) {
                    final byte[] buf = new byte[4096];
                    final int readBytes = in.read(buf);
                    if (readBytes < 0) {
                        return result.toString();
                    }
                    result.append(new String(buf, 0, readBytes, StandardCharsets.UTF_8));
                }
            } else {
                final InputStream in = process.getErrorStream();
                final StringBuilder result = new StringBuilder();
                for (;;) {
                    final byte[] buf = new byte[4096];
                    final int readBytes = in.read(buf);
                    if (readBytes < 0) {
                        return result.toString();
                    }
                    result.append(new String(buf, 0, readBytes, StandardCharsets.UTF_8));
                }
            }
        } catch (final IOException ex) {
            return null;
        } catch (final InterruptedException ex) {
            assert false : String.format("Not supposed to interrupt thread '%s'");
            return null;
        }
    }

    private static boolean listFiles(final String start, 
                                     final String filter,
                                     final ArrayList<String> files,
                                     final ArrayList<String> skips,
                                     final ArrayList<String> permissions,
                                     final ArrayList<String> dirs,
                                     final boolean recursive) {
        assert start  != null;
        assert filter != null;
        assert files  != null;
        assert skips  != null;

        final File directory = new File(start);
        final File[] list = directory.listFiles();
        if (list != null) {
            for (final File file : list) {
                if (file.getName().equals("X11")) {
                    continue; // note(nschultz): hack for Linux
                }

                if (!Files.isReadable(file.toPath())) {
                    permissions.add(file.getAbsolutePath());
                    continue;
                }

                if ((file.length() / 1024) > Config.maxSizeKB) {
                    skips.add(file.getAbsolutePath());
                    continue; // note(nschultz): prevent possible OOM
                }

                if (file.isFile()) {
                    if (filter != null) {
                        if (file.getName().matches(filter)) {
                            files.add(file.getAbsolutePath());
                        }
                    } else {
                        files.add(file.getAbsolutePath());
                    }
                } else if (file.isDirectory()) {
                    if (recursive) {
                        dirs.add(file.getAbsolutePath());
                        listFiles(file.getAbsolutePath(), filter, files, skips, permissions, dirs, recursive);
                    } else {
                        continue;
                    }
                }
            }
            return true;
        } else {
            return false;
        }
    }

    private static void sleepMillis(final long millis) {
        assert millis > 0;

        try {
            Thread.sleep(millis, 0);
        } catch (final InterruptedException ex) {
            assert false : String.format("Not supposed to interrupt thread '%s'\n", Thread.currentThread().getName());
        }
    }

    private static String getFileNameToDisplay(final String file) {
        assert file != null;

        String displayFileName = file;
        if (displayFileName.length() > 56) {
            displayFileName = "..." + file.substring(file.length() - 56);
        }
        return displayFileName;
    }

    private static String getSnapshotFileTime() {
        try {
            return Files.readAllLines(Config.snapshotFile).get(0);
        } catch (final Exception ex) {
            System.out.println("ERROR gasai: Failed to read snapshot file!");
            System.exit(ERR_SNAP);
        }
        return null; // note(nschultz): Unreachable
    }

    private static String getTimeStamp(final long millis) {
        final SimpleDateFormat formatter = new SimpleDateFormat("dd.MM.yyyy HH:mm:ss");
        final String date = formatter.format(new Date(millis));
        return date;
    }

    private static boolean isPlatformLinux() {
        return System.getProperty("os.name").equalsIgnoreCase("linux");
    }

    private static String getHash(final String file, final String algorithm) {
        assert file      != null;
        assert algorithm != null;

        if (Config.readSize > 0) { // only read that amount
            try (final FileInputStream in = new FileInputStream(file)) {
                final byte[] buf = new byte[Config.readSize];
                final int readBytes = in.read(buf); // note(nschultz): does NOT block on empty files since EOF is available

                final MessageDigest digest = MessageDigest.getInstance(algorithm);
                final byte[] hash = digest.digest(buf);
                final StringBuilder sHash = new StringBuilder(hash.length);
                for (final byte b : hash) sHash.append(String.format("%02X", b));
                
                return sHash.toString();
            } catch (final Exception ex) {
                System.out.println("ERROR gasai: Failed to retrieve hash value: " + ex.toString());
                System.exit(ERR_HASH);
            }
        } else { // note(nschultz): zero or negative value, so we will read the entire file into memory
            try (final BufferedInputStream in = new BufferedInputStream(new FileInputStream(file))) {
                final MessageDigest digest = MessageDigest.getInstance(algorithm);
                for (;;) {
                    final byte[] buf = new byte[Config.bufSize];
                    final int readBytes = in.read(buf);
                    if (readBytes < 0) break;
                    digest.update(buf, 0, readBytes);
                }
                final byte[] hash = digest.digest();
                final StringBuilder sHash = new StringBuilder(hash.length);
                for (final byte b : hash) sHash.append(String.format("%02X", b));

                return sHash.toString();
            } catch (final Exception ex) {
                System.out.println("ERROR gasai: Failed to retrieve hash value: " + ex.toString());
                System.exit(ERR_HASH);
            }
        }

        assert false : "Unreachable code path.";
        return null; // note(nschultz): will not happen since in case of an error we exit the JVM
    }

    private static CheckResults check() {
        if (!Files.exists(Config.snapshotFile)) {
            System.out.println("No snapshot file found!");
            System.out.println("Did you run 'gasai --update' beforehand?");
            System.exit(ERR_SNAP);
        }

        if (Config.snapTamperCheck) {
            if (Config.snapshotFile.toFile().lastModified() != 0) {
                System.out.println(VT_RED_FG + "---------------------------------------------------------------------" + VT_RESET);
                System.out.println(VT_RED_FG + "SUSPICIOUS: It looks like the snapshot file has been tampered with!!!" + VT_RESET);
                System.out.println(VT_RED_FG + "---------------------------------------------------------------------" + VT_RESET);
                sleepMillis(5000);
            }
        }

        System.out.printf(VT_BOLD + "Checking hashes (%s)..." + VT_RESET + "\n", Config.hash);

        final StringBuilder log = new StringBuilder(8192);
        log_header: {
            log.append(String.format("TIME            : %s", getTimeStamp(System.currentTimeMillis()))).append("\n");
            log.append(String.format("SNAPTIME        : %s", getSnapshotFileTime())).append("\n");
            log.append(String.format("DIRS            : %s", Arrays.toString(Config.dirs))).append("\n");
            log.append(String.format("MAXSIZEKB       : %s", Config.maxSizeKB)).append("\n");
            log.append(String.format("DELAY           : %s", Config.delayMillis)).append("\n");
            log.append(String.format("HASH            : %s", Config.hash)).append("\n");
            log.append(String.format("READSIZE        : %s", Config.readSize)).append("\n");
            log.append(String.format("SNAPPATH        : %s", Config.snapshotFile)).append("\n");
            log.append(String.format("LOGPATH         : %s", Config.logFile)).append("\n");
            log.append(String.format("RECURSIVE       : %s", Config.recursive)).append("\n");
            log.append(String.format("BUFSIZE         : %s", Config.bufSize)).append("\n");
            log.append(String.format("SNAPTAMPERCHECK : %s", Config.snapTamperCheck)).append("\n");
            log.append("\n\n\n");
        } 
        // note(nschultz): have to use these wrappers due to stupid '...must be effectively final' bs.
        final LongAdder processed = new LongAdder();
        final LongAdder changed   = new LongAdder();
        final LongAdder added     = new LongAdder();
        final LongAdder missing   = new LongAdder();

        final LinkedHashMap<String, String> oldSnapshot = new LinkedHashMap<>();
        retrieve_old_snapshot: {
            try {
                final String[] snapshotLines = Files.readString(Config.snapshotFile).split("\n");

                for (int i = 1; i < snapshotLines.length; ++i) { // note(nschultz): start with one in order to skip the timestamp line
                    final String line = snapshotLines[i];

                    if (line.split(":").length != 2) continue; // note(nschultz): happens when directory is empty
                    final String file = line.split(":")[0];
                    final String hash = line.split(":")[1];

                    oldSnapshot.put(file, hash);
                }

            } catch (final IOException ex) {
                System.out.println("ERROR gasai: Failed to load snapshot file: " + ex.toString());
                System.exit(ERR_SNAP);
            }
        }

        final ArrayList<String> currentFiles     = new ArrayList<>();
        final ArrayList<String> skippedFiles     = new ArrayList<>();
        final ArrayList<String> permissionsFiles = new ArrayList<>();
        final ArrayList<String> dirs             = new ArrayList<>();
        retrieve_current_files: {
            for (int i = 0; i < Config.dirs.length; ++i) {
                final boolean success = listFiles(Config.dirs[i], null, currentFiles, skippedFiles, permissionsFiles, dirs, Config.recursive);
                if (!success) {
                    System.out.printf("ERROR gasai: Failed to list all files in '%s'\n", Config.dirs[i]);
                    System.exit(ERR_LIST);
                }
            }
        }
        processed.add(currentFiles.size());

        skipped_files: {
            for (int i = 0; i < skippedFiles.size(); ++i) {
                final String displayFileName = getFileNameToDisplay(skippedFiles.get(i));
                System.out.printf("  %-59s [ %s ]\n", displayFileName, VT_YELLOW_FG + "SKIP" + VT_RESET);
                log.append(String.format("  %-59s [ %s ]\n", displayFileName, "SKIP"));

                if (Config.delayMillis > 0) {
                    sleepMillis(Config.delayMillis);
                }
            }
            for (int i = 0; i < permissionsFiles.size(); ++i) {
                final String displayFileName = getFileNameToDisplay(permissionsFiles.get(i));
                System.out.printf("  %-59s [ %s ]\n", displayFileName, VT_YELLOW_FG + "ROOT" + VT_RESET);
                log.append(String.format("  %-59s [ %s ]\n", displayFileName, "ROOT"));

                if (Config.delayMillis > 0) {
                    sleepMillis(Config.delayMillis);
                }
            }
        }

        compare_old_snapshot_with_current_state: {
            for (final String file : currentFiles) {
                if (Config.delayMillis > 0) {
                    sleepMillis(Config.delayMillis);
                }
                final String displayFileName = getFileNameToDisplay(file);

                if (oldSnapshot.get(file) == null) {
                    System.out.printf("  %-59s [ %s ]\n", displayFileName, VT_RED_FG + "ADDED" + VT_RESET);
                    log.append(String.format("  %-59s [ %s ]\n", displayFileName, "ADDED"));
                    added.increment();
                    continue;
                }

                final String currentHash = getHash(file, Config.hash);
                final String oldHash     = oldSnapshot.get(file); // can not be null since we checked earlier.
                oldSnapshot.remove(file);
                if (currentHash.equals(oldHash)) {
                    if (Config.verbose) System.out.printf("%s\n", currentHash.toString());
                    System.out.printf("  %-59s [ %s ]\n", displayFileName, VT_GREEN_FG + "OK" + VT_RESET);
                    log.append(String.format("  %-59s [ %s ]\n", displayFileName, "OK"));
                } else {
                    if (Config.verbose) System.out.printf("%s\n", currentHash.toString());
                    System.out.printf("  %-59s [ %s ]\n", displayFileName, VT_RED_FG + "CHANGED" + VT_RESET);
                    log.append(String.format("  %-59s [ %s ]\n", displayFileName, "CHANGED"));
                    changed.increment();
                }
            }

            // note(nschultz): Every file left in this map must be a missing one
            oldSnapshot.forEach((final String file, final String sha) -> {
                final String displayFileName = getFileNameToDisplay(file);

                System.out.printf("  %-59s [ %s ]\n", displayFileName, VT_RED_FG + "MISSING" + VT_RESET);
                log.append(String.format("  %-59s [ %s ]\n", displayFileName, "MISSING"));
                missing.increment();

                if (Config.delayMillis > 0) {
                    sleepMillis(Config.delayMillis);
                }
            });
        }

        write_to_log: {
            try {
                Files.writeString(Config.logFile, log.toString(), StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
            } catch (final IOException ex) {
                System.out.println("Failed to write to log: " + ex.toString());
            }
        }

        return new CheckResults(processed.intValue(),
                                changed.intValue(),
                                added.intValue(),
                                missing.intValue(),
                                skippedFiles.size() + permissionsFiles.size(),
                                dirs.size() + 1
        );
    }

    private static UpdateResults update() {
        System.out.printf(VT_BOLD + "Updating hashes (%s)..." + VT_RESET + "\n", Config.hash);

        final LongAdder fetched                     = new LongAdder();
        final ArrayList<String> files               = new ArrayList<>();
        final ArrayList<String> skippedFiles        = new ArrayList<>();
        final ArrayList<String> permissionsFiles    = new ArrayList<>();
        final ArrayList<String> dirs                = new ArrayList<>();
        final LinkedHashMap<String, String> mapping = new LinkedHashMap<>();

        for (int i = 0; i < Config.dirs.length; ++i) {
            final boolean success = listFiles(Config.dirs[i], null, files, skippedFiles, permissionsFiles, dirs, Config.recursive);
            if (!success) {
                System.out.printf("ERROR gasai: Failed to list all files in '%s'\n", Config.dirs[i]);
                System.exit(ERR_LIST);
            }
        }

        skipped_files: {
            for (int i = 0; i < skippedFiles.size(); ++i) {
                final String displayFileName = getFileNameToDisplay(skippedFiles.get(i));
                System.out.printf("  %-59s [ %s ]\n", displayFileName, VT_YELLOW_FG + "SKIP" + VT_RESET);
                if (Config.delayMillis > 0) {
                    sleepMillis(Config.delayMillis);
                }
            }

            for (int i = 0; i < permissionsFiles.size(); ++i) {
                final String displayFileName = getFileNameToDisplay(permissionsFiles.get(i));
                System.out.printf("  %-59s [ %s ]\n", displayFileName, VT_YELLOW_FG + "ROOT" + VT_RESET);
                if (Config.delayMillis > 0) {
                    sleepMillis(Config.delayMillis);
                }
            }
        }

        get_sha_hashes: {
            for (final String file : files) {
                final String currentHash = getHash(file, Config.hash);
                mapping.put(file, currentHash);

                final String displayFileName = getFileNameToDisplay(file);

                if (Config.verbose) System.out.printf("%s\n", currentHash);
                System.out.printf("  %-59s [ %s ]\n", displayFileName, VT_GREEN_FG + "SNAP" + VT_RESET);
                fetched.increment();

                if (Config.delayMillis > 0) {
                    sleepMillis(Config.delayMillis);
                }
            }
        }

        write_to_disk: {
            final StringBuilder dump = new StringBuilder(mapping.size() * 256);
            dump.append(getTimeStamp(System.currentTimeMillis())).append("\n");

            mapping.forEach((final String file, final String sha) -> {
                dump.append(String.format("%s:%s\n", file, sha));
            });
            try {
                Files.writeString(Config.snapshotFile, dump.toString(), StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
                if (Config.snapTamperCheck) {
                    Config.snapshotFile.toFile().setLastModified(0);
                }
            } catch (final IOException ex) {
                System.out.println("ERROR gasai: Failed to write update result to disk: " + ex.toString());
                System.exit(ERR_SNAP);
            }
        }
        return new UpdateResults(fetched.intValue(), skippedFiles.size() + permissionsFiles.size());
    }

    private static void printHelp() {
        System.out.printf("gasai v%s - personal security tool for my paranoia\n", VERSION);
        System.out.println();
        System.out.println("Summary");
        System.out.println("=======");
        System.out.println("This command line tool is rather simple, it checks files inside directories for");
        System.out.println("any changes. That includes new files being added, old ones being deleted and");
        System.out.println("any content differences.");
        System.out.println();
        System.out.println("Configuration file");
        System.out.println("==================");
        System.out.println("gasai uses one config file located in your home directory called .gasairc.");
        System.out.println("  dirs=dir1;dir2;            # the directories you wish to check");
        System.out.println("  delaymillis=milliseconds   # wait that many ms after each file check");
        System.out.println("  maxsizekb=size_in_kb       # do not check files that are larger than that");
        System.out.println("  verbose=false/true         # print additional information while running");
        System.out.println("  hash=algorithm             # the hash algorithm to use");
        System.out.println("  readsize=size_in_bytes     # how many bytes to use for the hash");
        System.out.println("  snapshotfile=path          # the path of the snapshotfile");
        System.out.println("  logfile=path               # the path of the logfile");
        System.out.println("  recurisve=false/true       # whether you wish to search recursively");
        System.out.println("  bufsize=size_in_bytes      # the buffer size used while reading");
        System.out.println("  snaptampercheck=false/true # whether you wish to perform basic tampering check");
        System.out.println();
        System.out.println("Usage");
        System.out.println("=====");
        System.out.println("gasai [--OPTION]");

        printOptions();

        System.out.println();
        System.out.println("Error codes");
        System.out.println("===========");
        System.out.println("ERR_SUCCESS 0");
        System.out.println("ERR_ARGS   -1");
        System.out.println("ERR_TERM   -2");
        System.out.println("ERR_SNAP   -4");
        System.out.println("ERR_LIST   -8");
        System.out.println("ERR_HASH   -16");
        System.out.println("ERR_RC     -32");
        System.out.println("ERR_INIT   -64");
        System.out.println();
        System.out.println("Files");
        System.out.println("=====");
        System.out.println(".gasairc");
        System.out.println(".gasai_hashes");
        System.out.println(".gasai.log");
        System.out.println();
        System.out.println("About");
        System.out.println("=====");
        System.out.println("Developed by Niklas Schultz");
        System.out.println("Copyright (c) 2022 Niklas Schultz");
        System.out.println("Licensed under MIT. See LICENSE file for more details.");
    }

    private static void printOptions() {
        System.out.println("Options:");
        System.out.println("  check   : Check if any hashes have changed since last update run.");
        System.out.println("  update  : Updates all hashes for the specified directories.");
        System.out.println("  init    : Create configuration template.");
        System.out.println("  hashes  : Prints all supported hash algorithms on this platform.");
        System.out.println("  rc      : Loads the configuration and prints the current settings.");
        System.out.println("  time    : Prints the last update time.");
        System.out.println("  options : Prints all supported command line arguments.");
        System.out.println("  version : Prints the version.");
        System.out.println("  help    : Prints this message.");
    }

    private static Path findRc() {
        home_dir: {
            final Path path = Path.of(System.getProperty("user.home"), ".gasairc");
            if (Files.exists(path)) {
                return path;
            }
        }

        etc_dir: {
            // todo(nschultz): if on linux
        }

        same_dir_as_script: {
            final URL location = gasai.class.getProtectionDomain().getCodeSource().getLocation();
            final File file = new File(location.getPath());
            final Path path = Path.of(file.getParent(), ".gasairc");
            if (Files.exists(path)) {
                return path;
            }
        }

        return null; // no rc found
    }

    private static void loadRc() {
        final Path rcFile = findRc();
        if (rcFile == null) {
            System.out.println("No .gasairc file found.");
            System.out.println("You can use 'gasai --init' to create a default configuration.");
            System.exit(ERR_RC);
        }

        String dirsTemp            = null;
        String delayMillisTemp     = null;
        String maxSizeKBTemp       = null;
        String verboseTemp         = null;
        String hashTemp            = null;
        String readSizeTemp        = null;
        String snapshotFileTemp    = null;
        String logFileTemp         = null;
        String recursiveTemp       = null;
        String bufSizeTemp         = null;
        String snapTamperCheckTemp = null;

        try {
            final String[] lines = Files.readString(rcFile).split("\n");
            for (int i = 0; i < lines.length; ++i) {
                if (lines[i].strip().startsWith("#")) continue; // note(nschultz): skip comments
                if (lines[i].strip().isEmpty())       continue; // note(nschultz): skip empty lines

                final String[] cfg = lines[i].split("=");
                if (cfg.length != 2) {
                    System.out.println("Invalid configuration syntax.");
                    System.exit(ERR_RC);
                }
                final String lhs = cfg[0];
                final String rhs = cfg[1];

                switch (lhs.toLowerCase()) {
                    case "dirs"            : { dirsTemp            = rhs; } break;
                    case "delaymillis"     : { delayMillisTemp     = rhs; } break;
                    case "maxsizekb"       : { maxSizeKBTemp       = rhs; } break;
                    case "verbose"         : { verboseTemp         = rhs; } break;
                    case "hash"            : { hashTemp            = rhs; } break;
                    case "readsize"        : { readSizeTemp        = rhs; } break;
                    case "snapshotfile"    : { snapshotFileTemp    = rhs; } break;
                    case "logfile"         : { logFileTemp         = rhs; } break;
                    case "recursive"       : { recursiveTemp       = rhs; } break;
                    case "bufsize"         : { bufSizeTemp         = rhs; } break;
                    case "snaptampercheck" : { snapTamperCheckTemp = rhs; } break;

                    default: {
                        System.out.println("Error while loading configuration:");
                        System.out.println("Unknown configuration key.");
                        System.out.println("Try running 'gasai --init' to create a default configuration.");
                        System.exit(ERR_RC);
                    } break;
                }
            }
        } catch (final IOException ex) {
            System.out.println("ERROR gasai: Failed to read configuration file.");
            System.exit(ERR_RC);
        }

        check_configuration: {
            dirs: {
                Config.dirs = dirsTemp.split(";");
                for (int j = 0; j < Config.dirs.length; ++j) {
                    if (Files.notExists(Path.of(Config.dirs[j]))) {
                        System.out.println("Error while loading configuration:");
                        System.out.printf("The directory '%s' does not exist. Perhaps you forgot to mount it?\n", Config.dirs[j]);
                        System.exit(ERR_RC);
                    }
                    if (!Files.isDirectory(Path.of(Config.dirs[j]))) {
                        System.out.println("Error while loading configuration:");
                        System.out.printf("'%s' is not a directory.\n", Config.dirs[j]);
                        System.exit(ERR_RC);
                    }
                }
            }

            delayMillis: {
                try {
                    Config.delayMillis = Integer.parseInt(delayMillisTemp);
                    if (Config.delayMillis < 0) {
                        System.out.println("Error while loading configuration:");
                        System.out.println("delaymillis must not be negative.");
                        System.exit(ERR_RC);
                    }
                } catch (final NumberFormatException ex) {
                    System.out.println("Error while loading configuration:");
                    System.out.println("Invalid delaymillis entry. Not a number.");
                    System.exit(ERR_RC);
                }
            }

            maxSizeKB: {
                try {
                    Config.maxSizeKB = Integer.parseInt(maxSizeKBTemp);
                    if (Config.maxSizeKB < 0) {
                        System.out.println("Error while loading configuration:");
                        System.out.println("maxsizekb must not be negative.");
                        System.exit(ERR_RC);
                    }
                } catch (final NumberFormatException ex) {
                    System.out.println("Error while loading configuration:");
                    System.out.println("Invalid maxsizekb entry. Not a number.");
                    System.exit(ERR_RC);
                }
            }

            verbose: {
                Config.verbose = Boolean.parseBoolean(verboseTemp);
            }

            hash: {
                Config.hash = hashTemp;

                final Set<String> algorithms = Security.getAlgorithms("MessageDigest");
                // linear search
                boolean supported = false;
                for (final String algorithm : algorithms) {
                    if (algorithm.equals(Config.hash)) {
                        supported = true;
                    }
                }
                if (!supported) {
                    System.out.println("Error while loading configuration:");
                    System.out.printf("Unsupported or unknown hash algorithm '%s'\n", Config.hash);
                    System.exit(ERR_RC);
                }
            }

            readSize: {
                try {
                    Config.readSize = Integer.parseInt(readSizeTemp);
                } catch (final NumberFormatException ex) {
                    System.out.println("Error while loading configuration:");
                    System.out.println("Invalid readSize entry. Not a number!");
                    System.exit(ERR_RC);
                }
            }

            snapshotFile: {
                try {
                    Config.snapshotFile = Path.of(snapshotFileTemp);
                    if (Files.isDirectory(Config.snapshotFile)) {
                        System.out.println("Error while loading configuration:");
                        System.out.println("Bad snapshot file path; must not be directory.");
                        System.exit(ERR_RC);
                    }
                } catch (final Exception ex) {
                    System.out.println("Error while loading configuration:");
                    System.out.println("Bad snapshot file path.");
                    System.exit(ERR_RC);
                }
            }

            logfile: {
                try {
                    Config.logFile = Path.of(logFileTemp);
                    if (Files.isDirectory(Config.logFile)) {
                        System.out.println("Error while loading configuration:");
                        System.out.println("Bad logfile path; must not be directory.");
                        System.exit(ERR_RC);
                    }
                } catch (final Exception ex) {
                    System.out.println("Error while loading configuration:");
                    System.out.println("Bad logfile path.");
                    System.exit(ERR_RC);
                }
            }

            recursive: {
                Config.recursive = Boolean.parseBoolean(recursiveTemp);
            }

            bufsize: {
                try {
                    Config.bufSize = Integer.parseInt(bufSizeTemp);
                    if (Config.bufSize <= 0) {
                        System.out.println("Error while loading configuration:");
                        System.out.println("Invalid bufsize entry. Must be at least 1.");
                        System.exit(ERR_RC);
                    }
                } catch (final NumberFormatException ex) {
                    System.out.println("Error while loading configuration:");
                    System.out.println("Invalid bufsize entry. Not a number!");
                    System.exit(ERR_RC);
                }
            }

            snaptampercheck: {
                Config.snapTamperCheck = Boolean.parseBoolean(snapTamperCheckTemp);
            }
        }
    }

    private static void init() {
        System.out.println("Creating new configuration...");
        try {
            Path rcFile = findRc();
            if (rcFile != null) {
                Files.delete(rcFile);
            }
            rcFile = Path.of(System.getProperty("user.home"), ".gasairc");

            default_values: {
                // note(nschultz): '/usr/bin/' is a good default I think because it probably is the first thing malware (e.g a rootkits) might
                // tamper with in order to make it undectable.
                Config.dirs            = new String[] {isPlatformLinux() ? "/usr/bin/" : System.getProperty("user.home")};
                Config.delayMillis     = 3;
                Config.maxSizeKB       = 8192;
                Config.verbose         = false;
                Config.hash            = "SHA-256";
                Config.readSize        = 0;
                // note(nschultz): it is good to make these configurable for several reason besides given the user
                // the possiblity two have mutliple versions of a snapshot file.
                // One reason is that it might be a bit harder for malware to detect the snapshot file (by name
                // at least) and mess with it.
                Config.snapshotFile    = Path.of(System.getProperty("user.home"), ".gasai_hashes");
                Config.logFile         = Path.of(System.getProperty("user.home"), ".gasai.log");
                Config.recursive       = false;
                Config.bufSize         = 4096; // note(nschultz): idk, likely a page I guess
                Config.snapTamperCheck = false;
            }

            final StringBuilder buffer = new StringBuilder();
            buffer.append("# ").append("\n");
            buffer.append("# ").append("\n");
            buffer.append("# ").append("\n");
            buffer.append("# Configuration file ").append("\n");
            buffer.append("# gasai ").append(VERSION).append("\n");
            buffer.append("# ").append("\n");
            buffer.append("# ").append("\n");
            buffer.append("# ").append("\n");
            buffer.append("\n\n\n");

            buffer.append("# the directories you wish to check separated by a semicolon").append("\n");
            buffer.append("dirs=");
            for (final String dir : Config.dirs) buffer.append(dir + ";");
            buffer.append("\n");

            buffer.append("# wait time in milliseconds before each file check").append("\n");
            buffer.append("delaymillis=").append(String.valueOf(Config.delayMillis)).append("\n");

            buffer.append("# do not check files which are bigger than this size").append("\n");
            buffer.append("maxSizekb=").append(String.valueOf(Config.maxSizeKB)).append("\n");

            buffer.append("# true or false depending on whether you wish to print verbose information").append("\n");
            buffer.append("verbose=").append(String.valueOf(Config.verbose)).append("\n");

            buffer.append("# the hash algorithm").append("\n");
            buffer.append("hash=").append(String.valueOf(Config.hash)).append("\n");

            buffer.append("# how many bytes are read from each file for the hash").append("\n");
            buffer.append("readsize=").append(String.valueOf(Config.readSize)).append("\n");

            buffer.append("# the path of the snapshotfile").append("\n");
            buffer.append("snapshotfile=").append(String.valueOf(Config.snapshotFile)).append("\n");

            buffer.append("# the path of the logfile").append("\n");
            buffer.append("logfile=").append(String.valueOf(Config.logFile)).append("\n");

            buffer.append("# whether you wish to search recursively").append("\n");
            buffer.append("recursive=").append(String.valueOf(Config.recursive)).append("\n");

            buffer.append("# the bufsize (in bytes) used while reading").append("\n");
            buffer.append("bufsize=").append(String.valueOf(Config.bufSize)).append("\n");

            buffer.append("# whether you wish to perform basic tampering check on snapshot file").append("\n");
            buffer.append("snaptampercheck=").append(String.valueOf(Config.snapTamperCheck)).append("\n");

            Files.writeString(rcFile, buffer.toString());

            System.out.println("New configuration has been created.");
        } catch (final IOException ex) {
            System.out.println("Failed to init: " + ex.toString());
            System.exit(ERR_INIT);
        }
    }

    private static void printHeader() {
        System.out.printf(VT_BOLD + VT_PURPLE_FG + "[ gasai %s ]\n" + VT_RESET, "version " + VERSION);
        System.out.println();
        sleepMillis(1500);
    }

    public static void main(final String[] args) {
        check_os: {
            if (!isPlatformLinux()) {
                System.out.println(VT_YELLOW_FG + "gasai has only been tested on Linux." + VT_RESET);
                System.out.println("Do you wish to continue anyway? Type 'yes' if you do.");
                final Scanner stdin = new Scanner(System.in);
                final String input = stdin.next();
                if (!input.equalsIgnoreCase("yes")) {
                    System.exit(ERR_SUCCESS);
                }
            }
        }

        check_temrinal_size: {
            if (isPlatformLinux()) {
                if (Integer.parseInt(execShellCommandWait("tput lines").strip()) < 25) {
                    System.out.println("gasai requires a minimum of 25 terminal lines.");
                    System.exit(ERR_TERM);
                }
                if (Integer.parseInt(execShellCommandWait("tput cols").strip()) < 80) {
                    System.out.println("gasai requires a minimum of 80 terminal cols.");
                    System.exit(ERR_TERM);
                }
            }
        }

        if (args.length == 0) {
            System.out.println("No arguments provided.");
            System.out.println("Try running gasai with '--help'.");
            System.exit(ERR_ARGS);
        }

        if (args.length == 1) {
            final String option = args[0];

            switch (option) {
                case "--check": {
                    printHeader();
                    loadRc();

                    final double startTime = (double) System.nanoTime();

                    final CheckResults results = check();
                    System.out.println();

                    if (!Config.recursive) {
                        if (Config.dirs.length == 1) {
                            System.out.printf("gasai has scanned %s directory.\n", Config.dirs.length);
                        } else {
                            System.out.printf("gasai has scanned %s directories.\n", Config.dirs.length);
                        }
                    } else {
                        if (results.dirsChecked == 1) {
                            System.out.printf("gasai has scanned %s directory.\n", results.dirsChecked);
                        } else {
                            System.out.printf("gasai has scanned %s directories.\n", results.dirsChecked);
                        }
                    }
                    System.out.println();
                    System.out.println("Results:");
                    System.out.println("  Processed files: " + results.processed);
                    System.out.println("  Skipped   files: " + results.skips);
                    System.out.println("  Changed   files: " + results.changed);
                    System.out.println("  Added     files: " + results.added);
                    System.out.println("  Missing   files: " + results.missing);
                    if (results.changed == 0 && results.added == 0 && results.missing == 0) {
                        System.out.println(VT_GREEN_FG + "No changes detected!" + VT_RESET);
                    } else {
                        System.out.println(VT_RED_FG + "Changes detected!" + VT_RESET);
                    }

                    final double endTime = (double) System.nanoTime();
                    final double elapsedTime = (double) (endTime - startTime) / 1000000000.0d;
                    System.out.println();
                    System.out.printf("Total elapsed time %.1f seconds\n", elapsedTime);
                } break;

                case "--update": {
                    printHeader();
                    loadRc();

                    final double startTime = (double) System.nanoTime();
                    final UpdateResults result = update();
                    System.out.println();
                    if (result.processed == 1) {
                        System.out.printf("gasai has updated '%s' hash.\n", result.processed);
                    } else {
                        System.out.printf("gasai has updated '%s' hashes.\n", result.processed);
                    }

                    final double endTime = (double) System.nanoTime();
                    final double elapsedTime = (double) (endTime - startTime) / 1000000000.0d;
                    System.out.printf("Total elapsed time %.1f seconds\n", elapsedTime);
                } break;

                case "--init": {
                    printHeader();

                    init();
                } break;

                case "--hashes": {
                    printHeader();

                    System.out.println("The following hash algorithms are supported on this platform:");
                    final Set<String> algorithms = Security.getAlgorithms("MessageDigest");
                    for (final String algorithm : algorithms) {
                        System.out.println("  " + algorithm);
                    }
                } break;

                case "--rc": {
                    printHeader();

                    loadRc();
                    final Path rcFile = findRc();
                    if (rcFile != null) { // note(nschultz): should never be null since loadRc already checks that...
                        System.out.println(findRc());
                    }
                    for (int i = 0; i < Config.dirs.length; ++i) System.out.printf("  Dir%s         : %s\n", i + 1, Config.dirs[i]);
                    System.out.printf("  delaymillis     : %s\n", Config.delayMillis);
                    System.out.printf("  maxsizekb       : %s\n", Config.maxSizeKB);
                    System.out.printf("  verbose         : %s\n", Config.verbose);
                    System.out.printf("  hash            : %s\n", Config.hash);
                    System.out.printf("  readsize        : %s\n", Config.readSize);
                    System.out.printf("  snapshotfile    : %s\n", Config.snapshotFile);
                    System.out.printf("  logfile         : %s\n", Config.logFile);
                    System.out.printf("  recursive       : %s\n", Config.recursive);
                    System.out.printf("  bufsize         : %s\n", Config.bufSize);
                    System.out.printf("  snaptampercheck : %s\n", Config.snapTamperCheck);
                } break;

                case "--time": {
                    printHeader();
                    loadRc();

                    if (Files.notExists(Config.snapshotFile)) {
                        System.out.println("No snapshot file found!");
                        System.out.println("Did you already run 'gasai --update'?");
                        System.exit(ERR_SNAP);
                    }
                    System.out.println(Config.snapshotFile.toString());
                    try {
                        System.out.println("  " + Files.readAllLines(Config.snapshotFile).get(0));
                    } catch (final Exception ex) {
                        System.out.println("ERROR gasai: Failed to read snapshot file!");
                        System.exit(ERR_SNAP);
                    }
                } break;

                case "--help": {
                    printHelp();
                } break;

                case "--options": {
                    printHeader();
                    printOptions();
                } break;

                case "--version": {
                    System.out.println(VERSION);
                } break;

                default: {
                    System.out.printf("Unknown argument '%s'\n", option);
                    System.out.println("Try running gasai with '--help'.");
                    System.exit(ERR_ARGS);
                } break;
            }
        } else {
            System.out.println("Too many arguments.");
            System.out.println("Try running gasai with '--help'.");
            System.exit(ERR_ARGS);
        }

        System.exit(ERR_SUCCESS);
    }
}
